#!/usr/local/www/cgi-bin/tablecg
#
# $DragonFly: site/data/goals/iomodel.cgi,v 1.7 2004/07/15 01:18:17 hmp Exp $
# $Id: iomodel.cgi,v 1.2 2004/08/24 13:59:41 wids Exp $

$TITLE(DragonFly - I/O Device Operations)

<h1>新しい I/O デバイスの形</h1>
<p>
大部分のデバイスが非同期的な API を持っているにも関わらず非同期的に動作するおかげで、 I/O は VFS より調整することが簡単になっています。
予定されている I/O モデルは 3 つの主要な作業から成っています:
</p>

<ol>
<li>
I/O データはシステムの範囲あるいはユーザアドレスの代わりに、VM オブジェクトの範囲によって示されることになるでしょう。
</li>

<li>
デバイスへの I/O は port/messaging システムを通して扱われるようになります。('messaging' を見てください)
</li>

<li>
通常、デバイスへの I/O はひとつかもっと多くのスレッドを通してシリアライズされるようになります。
各々のデバイスは、通常は独自のスレッドによって管理されることになりますが、ある特定の高性能なデバイスは多数のスレッド(CPU 1 つにつき 1 本追加)によって管理されるかもしれません。
マルチスレッドデバイスは必ずしもリソースの奪い合いをするわけではありません。
例えば、 TCP スタックは対象ポート数の剰余 N で分割した作業に対してマルチスレッドになりますが、それゆえに競合なしに多数のスレッドで(多数の CPU 上で)走ることになります。
</li>
</ol>

<p>
この作業の一部として、I/O メッセージはブロックナンバーよりもむしろフラットな 64-bit バイトオフセットを利用することになるでしょう。
</p>
<p>
デバイスメッセージはデバイスによって同期的に振舞うことができるということに注意してください。
それらがないという理由で、メッセージがデバイススレッドとして無条件にシリアライズされるという想定をする間違いをしないでください。
より詳しい情報はメッセージングセクションを見てください。
</p>
<p>
デバイスがカーネルスレッドよりもむしろユーザプロセスとして動作することを許すために、デバイスインターフェースは柔軟性を持つようにデザインされていることもまた注意すべきことです。
私達は多分しばらくの間はこの機能を得ることはできないでしょうが、この概念はいずれ実現するでしょう。
そこには仮想的なブロックデバイスやユーザ空間の中の統一的なファイルシステムのようなものでさえ透過的に扱うことができるために、数え切れない程の利点があります。
</p>
