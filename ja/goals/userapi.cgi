#!/usr/local/www/cgi-bin/tablecg
#
# $DragonFly: site/data/goals/userapi.cgi,v 1.8 2004/07/04 16:46:54 dillon Exp $
# $Id: userapi.cgi,v 1.2 2004/08/24 13:59:41 wids Exp $

$TITLE(DragonFly - User API)

<h1>移植性のあるユーザAPIを作る</h1>
<p>
多くの標準的な UNIX システムでは、生の構造体データを含む多種のデータを、システムコールテーブルを通じてやりとりします。
ユーザプログラムがそれ自身より古いあるいは新しいカーネルとやりとりする上で最大の障害は、これらの生の構造体データはよく構造が変わるということです。
最も厄介なのはネットワークインタフェイス、ルーティングテーブルの ioctl, ipfw, ps や vmstat が直接アクセスするプロセス構造体などです。
しかし、 stat() や readdir() のようなどうということのないシステムコールでさえ問題があります。
もっと一般的な言い方をすれば、システムコールはそれ自体が移植性の問題を生むことがあるということです。
</p>
<p>
このプロジェクトの目標として以下のものがあります。 
(1) 実質全てのシステムコールをメッセージベースにする。 
(2) 構造体の情報を、直接ではなく機能や要素のリストを通じて渡すようにする。 
(3) 汎用の「中間層」を実装する。 
(3) はある種のエミュレーション層のように見えるもので、管理はカーネルが行いますが、ユーザ空間にロードされます。
この層は全ての標準的なシステムコール API を実装し、それらを適切なメッセージに変換します。
</p>
<p>
例えば、 Linux エミュレーションはカーネルランドでなく(カーネルに保護された)ユーザランドで動作します。 
FreeBSD のエミュレーションも同じように動作します。
実際「ネイティブ」なプログラムもシステムコールという私達がよくなじんだものを見るためにエミュレーション層を通ります。
ただ違うのは、ネイティブなプログラムはエミュレーション層が存在し、ユーザランドから直接アクセスできるのを知っているので、ただカーネルに入ってすぐにエミュレーション層に戻るためだけに余分な INT0x80 (でも何でも)を無駄にしない、ということです。
</p>
<p>
システムコールをメッセージベースの構成要素に変更することによるもう一つの大きな利点は、ユーザランドスレッドの問題を完全に解決できるということです。
もう複数のユーザランドスレッドを処理するのに複数のカーネルコンテクストやスタックは必要なくなり、プロセスあたり<em>一つ</em>のカーネルコンテキストとスタックがあればよいのです。
ユーザランドスレッドはシステムの各 CPU ごとに実プロセスを生成するのに rfork() を使い続けますが、他全ての処理はスレッドに対応したエミュレーション層を使えます。
実際、ほとんど全てのユーザランドの upcall (コールバック)はカーネルから直接発行されるのではなく、ユーザランドのエミュレーション層から発行します。
以下はスレッド対応エミュレーション層が動作する例です:
</p>
<pre>
	ssize_t
	read(int fd, void *buf, size_t nbytes)
	{
	    syscall_any_msg_t msg;
	    int error;
	
	    /*
	     * Use a convenient mostly pre-built message stored in
	     * the userthread structure for synchronous requests.
	     */
	    msg = &amp;curthread->td_sysmsg;
	    msg->fd = fd;
	    msg->buf = buf;
	    msg->nbytes = bytes;
	    if ((error = lwkt_domsg(&amp;syscall_port, msg)) != 0) {
		curthread->td_errno = error;
		msg->result = -1;
	    }
	    return(msg->result);
	}
</pre>
<p>
たったこれだけです。 
DragonFly が実装する「本当の」システムコールは送信、受信、待機に必要な原始的なメッセージ通信機能のみです。
他はエミュレーション層を通過します。
もちろん、カーネルの側ではメッセージコマンドは FreeBSD 4.x にあるのと同じ規模のディスパッチテーブルにたどりつきます。
しかしサブシステムがメッセージベースになっていくにつれて、 syscall メッセージはよりいっそうこれらのサブシステムに統合されてゆくので、「メッセージ」を処理するためのオーバヘッドは最終的には独立したシステムコールを処理するオーバヘッドよりも小さくなるでしょう。
「エミュレーション層」はユーザランドプログラムが期待するものとカーネルが期待するものを分離するブラックボックスの役割をするので、移植性を確保することははるかに簡単になります。
エミュレーション層はカーネルといっしょに更新する(または後方互換性のあるバージョンを作る)ことができるため、ユーザランドのバイナリからは移植性の問題は見えなくなります。
</p>
<p>
加えて、メッセージパシングモデルが提供する利点を全て受けられます。
それはデバッグや他の目的のためにシステムコールに割込んだり、たとえばセキュリティ環境のもとづいて特定クラスのシステムコールを無効にしたり変更したりするといったセキュリティ層をカーネル内に構築するというものです。
</p>
