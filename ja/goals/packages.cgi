#!/usr/local/www/cgi-bin/tablecg
#
# $DragonFly: site/data/goals/packages.cgi,v 1.6 2004/04/16 13:23:37 justin Exp $
# $Id: packages.cgi,v 1.2 2004/08/24 13:59:41 wids Exp $

$TITLE(DragonFly - Packaging up the UserLand)

<h1>Dealing with Package Installation</h1>
<p>
シームレスなインストール作業と完璧な作業を得ることができるパッケージング・インストールシステムを考え出すことが難しい現在、アプリケーションはとてもひどく混乱しています。
問題の核心は、表面上は外部ライブラリ(それは我々の管理外)のマイナーアップデートであるように見えることですら、既にインストールされているアプリケーションを台無しにできることだという結論に私達は達しました。
パッケージングシステムが依存関係を管理し、アップグレードに必要な全てをアップグレードすることが<em>あり得る</em>のです。
問題は幾つかのアップグレードされた外部ライブラリのせいでアップグレードされる必要のあるパッケージやパッケージ群の新しいバージョンを、パッケージングシステムが実際には持っているわけではないということです。
</p>
<p>
私達は、望む特定のパッケージに依存した問題のあるアプリケーションを除いて、同パッケージのみをアップグレードする能力と高級さを必要としています。
これは「それが望ましい」ということではありません。
むしろ「それが必要である」ということです。
それは(アップグレードという)手続きの中で問題を引き起こす他の物事を心配することなしに、(パッケージングシステムデータベース自身の段階的な更新と同じように)断片的に(パッケージを)アップグレードすることを可能にするからです。
<i>最終的に</i>私達は全てを同調させたアップグレードを行おうと思っていますが、幾つかのパッケージがそうではなかった場合でさえ数日から数ヶ月の期間がかかりましたし、特定のとても大きなパッケージは、結局は長い間幾つかのライブラリの古いバージョンへ依存する結果になるかもしれません。
私達はそれをサポートできるようになることを望んでいます。
また私たちは port によってハードワイヤードされても大丈夫な、バージョン分けされた対応と設定(を行える)ディレクトリをサポートできるようになることも必要だと考えています。
このような競合が起こった場合、パッケージングシステムはバージョン分けに対応したディレクトリを同様に必要とします。
例えば 2 つの X というパッケージの互換性のないバージョン双方が /usr/local/etc/X を要求した場合は、 /usr/local/etc/X:VERION1 と /usr/local/etc/X:VERSION2 という形で対処できると思います。
</p>
<p>
/usr/lib や /usr/local/lib のような、また /usr/local/etc でさえ対応ディレクトリとして扱い、特定のライブラリの特定のバージョン、または/あるいはパッケージがそれが目に見えることを必要としたファイルのみ作る、ファイルシステムオーバーレイと呼ばれる '環境' と一体となった、はっきりとした依存性のバージョン管理とバイナリパッケージのタグ付けによって、この目標は成し遂げることが可能です。
その他のことはそのパッケージからは見えない状態になるでしょう。
可視性を強化することによって、特定のパッケージの依存性を不正確に指定した場合にとても素早く(それを)知ることができるでしょう。
何故なら、パッケージがインストールされた時にそれらが利用しやすい状態になっていないことによって、パッケージは誤って配置されたライブラリや対応したファイルを発見することができないからです。
例えば、パッケージがこのプログラムは ncurses のバージョン 1.5 に依存していると示している場合には、バージョン 1.5 がプログラムに対して可視になる全てになります(それは丁度 libncurses.* という形で見えると思います)。
</p>
<p>
上記のようなシステムの上では、きめ細かいバージョンコントロールがされたものも、またそうでないものであろうとも、(普通のシステムの上では)他のものと競合を起こしてしまうものでさえ、あらゆるものの複数のバージョンをインストールできるようになります。
そのパッケージングシステムはタグ付けされたバイナリに対して責任を持ち、オペレーティングシステムは可視性の管理に責任を持つことになります。
そのパッケージングシステム、あるいはおそらく単なる cron ジョブが、システムが走り続け、システムに依存して使われる全てのパッケージ群の更新完了後に、削除できる全ての '問題' を見つけ出すことへの責任を持つことになるでしょう。
</p>
<p>
他の可視性を強化することの現実的な利点は、パッケージが必要とする、あるいは必要としない何かについて、私達に楽観性を与えてくれるということです。
どんな依存関係があるか調査するためにパッケージングシステムを頼る必要はありません。バイナリに対してタグ付けされた環境を見るだけでいいんですから!
</p>
