#!/usr/local/www/cgi-bin/tablecg
#
# $DragonFly: site/data/goals/caching.cgi,v 1.5 2004/04/16 13:23:37 justin Exp $
# $Id: caching.cgi,v 1.2 2004/08/24 13:59:41 wids Exp $

$TITLE(DragonFly - A Scaleable Caching Infrastructure)

<h1>キャッシュ構造概説</h1>
<p>
私達の目標はよく知られ成熟している MESI (Modified Exclusive Shared Invalid) モデルによく似、各種設定の広い範囲にわたった柔軟で複数の目的に使用できるキャッシュ構造を生み出すことです。
この構造の第一の目的は I/O 処理を保護し、メモリマッピングを生かすことになります。
例えば、範囲ベースの MESI モデルは、 1 つのファイルの異なった位置へ書き込みと読み込みの両方を同時に実行する多様なプロセスを許容するでしょう。
私達がその構造を適切に実装できたなら、それをネットワーククラスタの環境に拡張することが可能ですし、それが single-system-image の将来を実現することに向けた長い道のりの出発点になるのです。
</p>
<p>
このようなキャッシュ構造は、競合する ftruncate() から write() を保護しますし、排他的な read() と write() 間を保護します。
同様のキャッシュ構造は動的な無効化あるいはメモリマッピングの再読み込みを行い、現在ロックされている VNODE の大部分を有効に再配置するでしょう。
</p>
<p>
予定されている構造は、 2 方向メッセージングを活用し、キャッシュデータの中央マネージャである VNode よりも、むしろ VM オブジェクト自体に焦点を合わせるでしょう。 
read() や write() のような幾つかの動作は、それらの I/O に由来する VM オブジェクトへ適切な範囲のロックをかけ、それからロックを開放するでしょう。
長期間にわたるキャッシュ動作は、保持されているロックの範囲の数をバウンドさせあう範囲を壊す場合があるかも知れません。そしてそれはその構造に動作間のロックをスケーラブルな方法で保持することを許しています(:?)。
このようなケースでは、キャッシュ動作(:?演算)は、例えば"無効になるかあるいは Exclusive から Shared へ移行するか"というその範囲ロックを降格させるか開放させるかを尋ねるメッセージを、保持している要素に対して出力するでしょう。
言いかえれば、予定されているキャッシュシステムは<i>積極的に管理された</i>システムなのです。
</p>
