#!/usr/local/www/cgi-bin/tablecg
#
# $DragonFly: site/data/goals/vfsmodel.cgi,v 1.5 2004/04/16 13:23:37 justin Exp $
# $Id: vfsmodel.cgi,v 1.2 2004/08/24 13:59:41 wids Exp $

$TITLE(DragonFly - VFS/filesystem Device Operations)

<h1>新しい VFS モデル</h1>
<p>
おそらく VFS サブシステムを修正することは私達が取り組む作業の中では最大のものです。 
VFS には多くの作業が必要となるであろう、 2 つの深刻な問題があります。
第一に、現在の VFS の API は、大規模な再入モデルをそのコア部分にまで幅広く使っており、私達はスレッド化されたメッセージング API へそれを適合させることを望んでいます。
第二に、現在の VFS の API はシステムの中で最も複雑なインターフェースのひとつを持っています ... 例えば、ファイルパスを解析する VOP_LOOKUP 等。 
VFS を修正するには主に 2つの作業が必要です。
</p>
<p>
第一に、VOP_LOOKUP のインターフェースと VFS キャッシュは完全に再修正される予定です。
全てのファイルパスは<em>いかなる</em> VFS の動作がはじまるよりも前にカーネルによって VFS キャッシュの中に未解決の状態のまま読み込まれるようになるでしょう。
カーネルは VFS キャッシュ を再帰的に検索し、要素に当たった時に未解決のパスの要素を表現するために新しいエントリを作りはじめるでしょう。
蛇の尾はその次に変換(:?)のために VFS_LOOKUP() によって掴まれることになります。
もしさらなる変換が必要となっても、VFS_LOOKUP() は新しい VFS ポインタを返すことが可能になるでしょう。
例えば、それはマウントポイントにも当てはまります。
カーネルはもはや VFS サブシステムに対しユーザが提供したランダムな文字列(そしてユーザアドレス空間を使用することはなくなります)を渡すことはなくなります。
</p>
<p>
第二に、一般的に VOP インターフェースはメッセージングインターフェースに変換されることになる予定です。
直接ユーザ空間のアドレスはカーネルによって VM オブジェクトの範囲の中で解決されるでしょう。 
VOP インターフェースは直接ユーザ空間のアドレスをそれ以上<em>扱いません</em>。
メッセージングインターフェースとしての VOP はまだ同期的に動作することができますし、それが私達がはじめにしようと考えていることです。
しかし、われわれの狙いは VOP インターフェースの大部分をスレッドとして動作するようにすることです(つまり、大規模な再入可能モデルをシリアライズされスレッド化されたメッセージモデルによって置き換える)。
複数のスレッド(1 CPU につきひとつ)が走る高性能ファイルシステムでは、理論上、大規模な再入可能モデルが実現できるものと同じレベルの性能を実現することが可能です。
しかしながら、全てのファイルシステムのコードで見られる bread() のような扱いにくいブロッキングポイントは非同期的でなくてはならないか、あるいは並列処理を扱うために更に多くのスレッドを生成しなければならないのです。
はじめに私達は(莫大な)性能を達成しひとつのスレッドの中で VOP の動作をシリアライズし、次に UFS のように配慮するファイルシステムを最適化できるようになります。
大規模な再入可能モデルはファイルシステムに対して、 16スレッドモデルよりよく機能することはありません(:?)。
なぜなら、双方の場合で I/O がボトルネックになるからです(:?)。
ひとつのスレッドがノンブロッキングな(キャッシュされた)要求を扱う限り、大規模な再入可能モデルの 95% の性能を実現することが可能です。
</p>
<p>
<!--<<<<<<<<<<<<-->
メッセージングインタフェイスは多くの理由から好ましいものです。
特に独立的で不透明な要素が積み重なって全体を形成するという、スタッキングが本来すべき動作を実現するという点によるところが少なくありません。
たとえば新しい API では、ファイルシステムが実装していない機能に対して機能層をあてがうことができ、エンドユーザにはその違いが分かりません。
ファイルシステムは大部分が自己完結型<!--相互依存する別の要素を持たないという意味-->の要素です。
メッセージベースの API では、これらの要素をデバッグのためにユーザランドで動作させることを可能にしますし、また絶対にクラッシュしてはいけないような場合にも威力を発揮します。 
msdosfs や cd9660 がユーザランドでも同じように動作するなら、わざわざカーネルの中で動かしてクラッシュする危険にさらす必要はないでしょう? 
<!--============
メッセージングインタフェースは多くの点で優れています。
それは、スタッキングのあるべき姿である、独立なカプセル化された要素が積み重なって全体を形成するということを実現したことによるところが少なくありません。
例えば、新しい API ではファイルシステムに実装されていなかった機能の機能層をかぶせることができ、しかもエンドユーザには元から実装されていたときとの違いがわかりません。
また、ファイルシステムはどれもほとんど例外なく自己完結したひとまとまりのオブジェクトになっています。
メッセージベースの API ではこれらのオブジェクトをユーザ空間で動かすことができ、デバッグにも使えれば、クラッシュが絶対許されない条件下の運用にも威力を発揮します。 
msdosfs や cd9660 がユーザ空間でも同じように動作するならわざわざカーネルの中で動かしてクラッシュする危険にさらす必要はないでしょう? 
>>>>>>>>>>>>-->
デバッグやファイルシステムの開発では、大規模な再入可能 API より、メッセージ API を持つための他のよい理由があるのです。
</p>
