#!/usr/local/www/cgi-bin/tablecg
#
# $DragonFly: site/data/goals/threads.cgi,v 1.11 2004/09/07 01:56:57 justin Exp $
# $Id: threads.cgi,v 1.3 2004/10/06 14:51:24 wids Exp $

$TITLE(DragonFly - Light Weight Kernel Threading Model)

<h2>軽量カーネルスレッドモデル</h2>
<p>
DragonFly はその中核部分に軽量カーネルスレッド(LWKT)を用います。
システムのプロセスは全てスレッドと結びついていて、カーネルのみのプロセスのほとんどは事実上純粋なスレッドです。
たとえば、 pageout デーモンは純粋なスレッドでプロセスコンテクストを持ちません。
</p>
<p>
LWKT モデルはアーキテクチャによらないいくつかの鍵となる特徴があります。
これらの特徴は CPU 間の競合を除く、あるいは減らすために設計されています。
</p>
<ol>
    <li><p>
    システムの各 CPU は自己完結の LWKT スケジューラを持ちます。
    スレッドは意図的に CPU に結びついていて、いくつかの特殊な状況下でのみ他の CPU へ移動することができます。
    特定の CPU 上の LWKT スケジューリング処理はその CPU 上でのみ直接実行されます。
    これは、 LWKT スケジューラ本体がスケジュール追加、除去、 CPU 内でのスレッド間スイッチを、ロックを一切せずに処理できるということです。
    単純なクリティカルセクションの除いては MP ロックもなにもなしにです。
	</p></li>
    <li><p>
    スレッドはカーネルで動作中は他の CPU にプリエンプティブに移動されることはありません。
    スレッドはブロックされている間は CPU 間を移動しません。
    ユーザランドスケジューラはユーザモードで実行しているスレッドを移動できます。
    スレッドは非割り込みスレッドへプリエンプティブにスイッチすることはありません。
    割り込みスレッドがカレントスレッドをプリエンプトする場合、割り込みスレッドが終了またはブロックした時点でプリエンプトされた方のスレッドはスケジュール状態によらず復元されます。
    たとえば、あるスレッドは lwkt_deschedule_self() を呼んだあと、実際に別のスレッドへスイッチする前にプリエンプトされる可能性があります。
    これは問題ありません。
    なぜなら割り込みスレッドが完了またはブロックしたあとそのスレッドに直接制御が戻るからです。
	</p></li>
    <li><p>
    上の (2) により、スレッドは CPU ごとの globaldata 構造体を通じて得た情報をロックなしにキャッシュすることができます。
    また、その情報が割り込みスレッドによって変更されないと分かっている場合は、クリティカルセクションに入る必要がありません。
    これによって、いろいろな種類のデータの CPU ごとのキャッシュ<!--(訳注: 「の」の連続だ)-->を、事実上オーバヘッドなしに持つことができます。
	</p></li>
    <li><p>
    ある CPU が他の CPU に属するスレッドをスケジュールしようとする場合は、ターゲット CPU に IPI ベースのメッセージを発行して、処理を実行します。
    このメッセージはデフォルトで非同期で、このため IPI はレイテンシを伴うことがありますが必ずしも CPU サイクルを浪費するとは限りません。
    この IPI の処理はクリティカルセクションに入ったスレッドによってブロックされます。
    実際、 LWKT  スケジューラはそうします。
    クリティカルセクションの出入りは安価な処理と考えられるので、ロックやバスロック命令を必要としません。
	</p></li>
    <li><p>
    IPI メッセージサブシステムは FIFO あふれによるデッドロックに対し、送信キューの停滞が解消するのを待つ間、受信キューをスピンして処理することで対処します。 
    IPI メッセージサブシステムはこのような状況下で特にスレッドのスイッチを行いません。
    これによって、まれにスピンが発生する場合があってもソフトウェアはこれをノンブロッキング API のように扱うことができます。
	</p></li>
</ol>
<p>
これらの鍵となる特徴に加え、 LWKT モデルでは高速割込みプリエンプション<em>と</em>スレッド割込みプリエンプションを両立します。
高速割り込みはカレントスレッドがクリティカルセクションに入っていない場合はプリエンプトできます。
スレッド割込みもカレントスレッドをプリエンプトできます。 
LWKT システムは、スレッド割込みにスイッチしたあとそれがブロックまたは完了した場合にもとのスレッドに戻ります。 
IPI 関数は高速割り込みと非常に似たやり方で動作し、同じく trapframe 機能を持ちます。
これは DragonFly の SYSTIMERS API で hardclock() や statclock() の割込みを全ての CPU に分配するために多く用いられています。
</p>

<h2>IPI メッセージサブシステム</h2>
<p>
LWKT モデルは CPU 間通信のための非同期メッセージシステムを実装します。
基本的には、関数ポインタとデータ引数を引数として関数を呼び出すとターゲット CPU にそれを渡り、ターゲット CPU はそれを非同期に実行します。
これは非同期モデルなので呼び側は同期完了を待ちません。
このため性能が非常に向上し、ターゲット CPU へのオーバヘッドもおおまかには割り込みと同等程度です。
</p>
<p>
IPI メッセージは高速割り込みのように動作します...つまり(クリティカルセクションに左右されますが)ターゲット CPU で動いているものは何でもプリエンプトし、実行し、そのあともともと動いていたものに復帰します。
このため IPI 関数はいかなる理由であってもブロックすることは許されません。 
IPI メッセージはスレッドをスケジュールしたり他の CPU に属しているメモリを解放するといった処理をするのに用いられます。
</p>
<p>
IPI メッセージ処理は少なくとも 6 個の主な LWKT サブシステムで多用されています。
それらには、 CPU ごとのスレッドスケジューラ、 slab allocator 、メッセージサブシステムが含まれています。 
IPI メッセージ処理は DragonFly に本来的に適応したサブシステムなので、 Big Giant Lock を必要とせず、使用してもいません。
全ての IPI ベースの関数は従って MP セーフである必要があります(そうなっています)。
</p>

<h2>IPI ベースの CPU 同期サブシステム</h2>
<p>
</p>
LWKT モデルは、汎用でマシンに依存しない CPU 同期 API が備わっています。
この API によって、デリケートなデータ構造にアクセスしている状態のターゲット CPU を既知の状態に移行させることができます。
このインタフェイスは主に MMU のページテーブルを更新するのに使用されています。
たとえば、もし適切なロックを確保していたとしても、ページテーブルエントリのモディファイビットをテスト、クリアしたあとにページテーブルエントリを削除するのは安全ではありません。
これは、他の CPU で動作しているユーザランドプロセスがそのページを読み書きする可能性があるからで、その場合向こう側の CPU が TLB を書き戻すのとページテーブルエントリをクリアしようとする処理の間にレース状態が生じます。
適切な解決は、ページテーブルエントリへ書き戻す可能性のある CPU (つまり pmap の pm_active マスクでセットされている全 CPU)をまず既知の状態に移行し、変更処理をしてから、各 CPU の TLB を無効化するリクエストによって CPU を解放するという方法です。
<p>
DragonFly に備わっている API にはデッドロックがありません。
複数の CPU 同期処理が並行に動作することが可能で、これは CPU 同期イベントの主導権を握っているスレッドにもあてはまります。
これは柔軟なしくみですが、 CPU 同期インタフェイスは制御された環境で動作するため、コールバック関数は IPI メッセージサブシステムで用いられるものとちょうど同じように動作する傾向にあります。
</p>

<h2>同期トークン</h2>
<p>
同期トークンはいくつものスレッドが同時につかめます。
トークンをつかんでいるスレッドは、同一のトークンをつかんでいる他のスレッドが同時には実行しないことが保証されます。
</p>

<p>
一つのスレッドは同期トークンをいくつでもつかむことができます。
</p>

<p>
あるスレッドは、イールドまたはブロック条件を通じて同期トークンをつかむことがありますが、そのスレッドが(ブロックあるいはイールドされて)実行中でない間、それらのトークンをつかんでいる他のスレッドが実行する可能性があることを考慮に入れる必要があります。
</p>

<p>
理論上、同期トークンの機構から起きるデッドロック状態で解決できないものはありません。
しかし、初期の実装ではトークンを同時につかんだ場合にライブロックの問題が起きる可能性があります。
</p>

<p>
同期トークンは、同一のトークンをつかもうとする割り込みが他のスレッドをプリエンプトしてしまうことから保護するのにも使われます。
これは Big Giant Lock (MP ロックともいう)とは若干違った作用があります。 
BGL は同一 CPU の割り込みをインターロックすることはありません。
<i>重要なことは、プリエンプションによって一時的に他のスレッドへのスイッチが起きることがあるとしても、トークンの不可分性(atomicity)プリエンプティブ条件によって維持されるということです。
トークンの不可分性(atomicity)を維持するために spl() レベルやクリティカルセクションに入る必要はありません</i>。
</p>

<p>
同期トークンはプリエンプティブは割り込みが起きるのをさまたげることは<b>ありません</b>が、割込みをブロックして再スケジュールさせることがあります。
スレッド化されていない高速割り込みや IPI メッセージング割り込みはトークンをつかうことができません。
それは処理に必要なスレッドコンテキストを持っていないからです。
そのかわり、これらのサブシステムはクリティカルセクションを使うことで排他制御をします。
</p>
